// Nixie Â© Karim Vergnes <me@thesola.io>
// Licensed under GNU GPLv2
// Final-step Nix invocation methods

import { file_exists, dir_exists, dir_create } from "std/fs"

import { enter_alt_buffer, set_title, teardown }  from "./term.ab"
import { bail }                                   from "./common.ab"
import { get_osname, get_system, get_cache_root } from "./platform.ab"
import { pull_binary }                            from "./resources.ab"
import { build_nix }                              from "./builder.ab"

/// Determine whether Nix is installed system-wide. Nixie can launch the
/// system-wide Nix when it is available, using the script's bundled options.
///
/// This is the predicate for that behavior.
fun is_nix_installed(): Bool
{
    // --nixie-ignore-system flag set
    if env_var_test("nosystem"): return false

    // Simple enough heuristic. In the future, might also check for the `nix`
    // command, but that would create a ternary situation where Nixie's static
    // Nix would need to use the system store.
    if dir_exists("/nix/store"): return true

    return false
}

/// Attempt to retrieve the static Nix binary by all known methods.
///
/// This function will first try to extract or download a static executable
/// for the current system, and if it fails, a local build from source will be
/// attempted.
///
/// **NOTE**: On macOS, this function is also responsible for downloading
/// `libfakedir.dylib`.
fun get_nix()
{
    let cache_root = get_cache_root()
    let osname = get_osname()
    let system = get_system()

    let nix_path = "{cache_root}/nix-static"
    let fakedir_path = "{cache_root}/nix-lib/libfakedir.dylib"

    enter_alt_buffer()
    set_title("Building Nix...")

    // Cleanly exit alt-buffer if hit with ^C
    trust $trap "{nameof teardown}; exit 1" SIGKILL SIGTERM SIGINT SIGABRT$

    if osname == "Darwin" and not file_exists(fakedir_path) {
        dir_create("{cache_root}/nix-lib")
        trust pull_binary("libfakedir.dylib", fakedir_path)
    }

    if not file_exists(nix_path) {
        trust pull_binary("nix.{system}", nix_path)
    }

    echo "Pretend we're doing something here..."
    trust $sleep 1$

    // By this point every attempt at fetching Nix failed.
    teardown()
    fail 1
}

/// Launch Nix with the proper environment variables for fakedir and OpenSSL.
///
/// This is required because macOS has no namespacing facility, and Nix will
/// not attempt to use the system-wide CA bundle by default. This function
/// addresses both issues.
fun launch_darwin_workaround(name: Text, args: [Text]): Null
{

}

/// Launch Nix with options pulled from a file's contents.  
/// This allows our script to be used as an interpreter, the same way
/// Nix proper would.
pub fun launch_nix_shebang(name: Text, file: Text, args: [Text]): Null
{

}

/// Launch Nix as a regular CLI.
pub fun launch_nix(name: Text, extras: [Text], args: [Text]): Null
{
    trust get_nix()

    echo "Would launch Nix as {name}"
    echo "Internal options: {extras}"
    echo "Command line options: {args}"
    echo ""
    echo "That's all we have for now, thanks for playing!"
    exit 0
}
