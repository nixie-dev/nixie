// Nixie Â© Karim Vergnes <me@thesola.io>
// Licensed under GNU GPLv2
// Final-step Nix invocation methods

import { file_exists, dir_exists, dir_create }  from "std/fs"
import { env_var_test, env_var_set }            from "std/env"

import { enter_alt_buffer, set_title, teardown }  from "./term.ab"
import { bail }                                   from "./common.ab"
import { get_osname, get_system, get_cache_root, get_nix_root } from "./platform.ab"
import { pull_binary }                            from "./resources.ab"
import { try_build_nix }                          from "./builders.ab"

/// Determine whether Nix is installed system-wide. Nixie can launch the
/// system-wide Nix when it is available, using the script's bundled options.
///
/// This is the predicate for that behavior.
fun is_nix_installed(): Bool
{
    // --nixie-ignore-system flag set
    if env_var_test("nosystem"): return false

    // Simple enough heuristic. In the future, might also check for the `nix`
    // command, but that would create a ternary situation where Nixie's static
    // Nix would need to use the system store.
    if dir_exists("/nix/store"): return true

    return false
}

/// Attempt to retrieve the static Nix binary by all known methods.
///
/// This function will first try to extract or download a static executable
/// for the current system, and if it fails, a local build from source will be
/// attempted.
///
/// **NOTE**: On macOS, this function is also responsible for downloading
/// `libfakedir.dylib`.
fun get_nix()
{
    let cache_root = get_cache_root()
    let osname = get_osname()
    let system = get_system()

    let nix_path = "{cache_root}/nix-static"
    let fakedir_path = "{cache_root}/nix-lib/libfakedir.dylib"

    enter_alt_buffer()
    set_title("Building Nix...")

    // Cleanly exit alt-buffer if hit with ^C
    trust $trap "{nameof teardown}; exit 1" SIGKILL SIGTERM SIGINT SIGABRT$

    if osname == "Darwin" and not file_exists(fakedir_path) {
        dir_create("{cache_root}/nix-lib")
        trust pull_binary("libfakedir.dylib", fakedir_path)
    }

    if is_nix_installed() {
        teardown()
        return 0
    }

    // We already have static Nix
    if file_exists(nix_path) {
        teardown()
        return 0
    }

    //TODO: Debug! Remove before release!
    if env_var_test("nobins") {
        trust try_build_nix()
        teardown()
        fail status
    }

    // Try to extract or download Nix
    pull_binary("nix.{system}", nix_path) failed {
        trust try_build_nix()
        teardown()
        fail status
    }

    teardown()
    return 0
}

/// Move the contents of the user Nix store into the system Nix store.
///
/// This reduces occupied storage space in the event that the user installed
/// Nix system-wide between uses of our script.
fun migrate_nix_store()
{
    let nix_root = get_nix_root()

    if not dir_exists("{nix_root}/nix/store"):
        return 0

    echo "Migrating Nix store to system-wide install..."
    trust $nix copy --from {nix_root} --all --no-check-sigs$
    if status == 0 {
        trust $chmod -R +wx {nix_root} && rm -rf {nix_root}$
    }
}

/// Launch Nix with the proper environment variables for fakedir and OpenSSL.
///
/// This is required because macOS has no namespacing facility, and Nix will
/// not attempt to use the system-wide CA bundle by default. This function
/// addresses both issues.
///
/// **This function does not return.**
fun launch_darwin_workaround(name: Text, args: [Text]): Null
{
    let cache_root = get_cache_root()
    let nix_root = get_nix_root()

    let nix_path = "{cache_root}/nix-static"
    let fakedir_path = "{cache_root}/nix-lib/libfakedir.dylib"

    trust env_var_set("FAKEDIR_PATTERN", "/nix")
    trust env_var_set("FAKEDIR_TARGET", "{nix_root}/nix")

    trust $export FAKEDIR_PATTERN FAKEDIR_TARGET$

    // We need to ensure fakedir gets propagated into child processes as well.
    // Unfortunately, this requires us to disable the Nix sandbox entirely.
    trust $ _NIX_TEST_NO_SANDBOX=1 \
            DYLD_INSERT_LIBRARIES="{fakedir_path}" \
            DYLD_LIBRARY_PATH="{cache_root}/nix-lib" \
                exec -a {name} {nix_path} {args}$
}

/// Launch Nix with options pulled from a file's contents.  
/// This allows our script to be used as an interpreter, the same way
/// Nix proper would.
///
/// **This function does not return.**
pub fun launch_nix_shebang(name: Text, file: Text, args: [Text]): Null
{

}

/// Launch Nix as a regular CLI.
///
/// **This function does not return.**
pub fun launch_nix(name: Text, extras: [Text], args: [Text]): Null
{
    get_nix() failed { echo "oh nyo" }

    echo "Would launch Nix as {name}"
    echo "Internal options: {extras}"
    echo "Command line options: {args}"
    echo ""
    echo "That's all we have for now, thanks for playing!"
    exit 0
}
