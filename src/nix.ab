// Nixie Â© Karim Vergnes <me@thesola.io>
// Licensed under GNU GPLv2
// Final-step Nix invocation methods

import { file_exists, dir_exists, dir_create }  from "std/fs"
import { env_var_test, env_var_set }            from "std/env"
import { split, slice, starts_with, ends_with } from "std/text"
import { array_last, array_shift }              from "std/array"

import { enter_alt_buffer, set_title, teardown }  from "./term.ab"
import { bail }                                   from "./common.ab"
import { get_osname, get_system, get_cache_root, get_nix_root } from "./platform.ab"
import { pull_binary }                            from "./resources.ab"
import { try_build_nix }                          from "./builders.ab"

/// Determine whether Nix is installed system-wide. Nixie can launch the
/// system-wide Nix when it is available, using the script's bundled options.
///
/// This is the predicate for that behavior.
fun is_nix_installed(): Bool
{
    // --nixie-ignore-system flag set
    if env_var_test("nosystem"): return false

    // Simple enough heuristic. In the future, might also check for the `nix`
    // command, but that would create a ternary situation where Nixie's static
    // Nix would need to use the system store.
    if dir_exists("/nix/store"): return true

    return false
}

/// Attempt to retrieve the static Nix binary by all known methods.
///
/// This function will first try to extract or download a static executable
/// for the current system, and if it fails, a local build from source will be
/// attempted.
///
/// **NOTE**: On macOS, this function is also responsible for downloading
/// `libfakedir.dylib`.
fun get_nix()
{
    let cache_root = get_cache_root()
    let osname = get_osname()
    let system = get_system()

    let nix_path = "{cache_root}/nix-static"
    let fakedir_path = "{cache_root}/nix-lib/libfakedir.dylib"

    enter_alt_buffer()
    set_title("Building Nix...")

    // Cleanly exit alt-buffer if hit with ^C
    trust $trap "{nameof teardown}; exit 1" SIGKILL SIGTERM SIGINT SIGABRT$

    if osname == "Darwin" and not file_exists(fakedir_path) {
        dir_create("{cache_root}/nix-lib")
        pull_binary("libfakedir.dylib", fakedir_path)?
    }

    // We already have static Nix
    if file_exists(nix_path) {
        teardown()
        return 0
    }

    //TODO: Debug! Remove before release!
    if env_var_test("nobins") {
        trust try_build_nix()
        teardown()
        fail status
    }

    // Try to extract or download Nix
    pull_binary("nix.{system}", nix_path) failed {
        trust try_build_nix()
        teardown()
        fail status
    }

    trust $chmod +x {nix_path}$

    teardown()
    return 0
}

/// Move the contents of the user Nix store into the system Nix store.
///
/// This reduces occupied storage space in the event that the user installed
/// Nix system-wide between uses of our script.
fun migrate_nix_store()
{
    let nix_root = get_nix_root()

    if not dir_exists("{nix_root}/nix/store"):
        return 0

    echo "Migrating Nix store to system-wide install..."
    trust $nix copy --from {nix_root} --all --no-check-sigs$
    if status == 0 {
        trust $chmod -R +wx {nix_root} && rm -rf {nix_root}$
    }
}

/// Launch Nix with the proper environment variables for fakedir and OpenSSL.
///
/// This is required because macOS has no namespacing facility, and Nix will
/// not attempt to use the system-wide CA bundle by default. This function
/// addresses both issues.
///
/// **This function does not return.**
fun launch_darwin_workaround(name: Text, nix_path: Text, args: [Text]): Null
{
    let cache_root = get_cache_root()
    let nix_root = get_nix_root()

    let fakedir_path = "{cache_root}/nix-lib/libfakedir.dylib"

    trust env_var_set("FAKEDIR_PATTERN", "/nix")
    trust env_var_set("FAKEDIR_TARGET", "{nix_root}/nix")

    trust $export FAKEDIR_PATTERN FAKEDIR_TARGET$

    // We need to ensure fakedir gets propagated into child processes as well.
    // Unfortunately, this requires us to disable the Nix sandbox entirely.
    trust $ _NIX_TEST_NO_SANDBOX=1 \
            DYLD_INSERT_LIBRARIES="{fakedir_path}" \
            DYLD_LIBRARY_PATH="{cache_root}/nix-lib" \
                exec -a {name} {nix_path} {args}$
}

/// Launch Nix with options pulled from a file's contents.
///
/// This allows our script to be used as an interpreter, the same way
/// Nix proper would.
///
/// ### Arguments:
/// - `nix_path`: Path to the Nix executable to use (local or installed)
/// - `file`: The filename to interpret with Nix
/// - `extras`: Internal options to append to the Nix command line
/// - `args`: Command line options to pass to the interpreted file
pub fun launch_nix_shebang(nix_path: Text, file: Text, extras: [Text], args: [Text]): Null
{
    let shebang = ""
    for i, line in lines(file) {
        if i == 1 {
            shebang = line
            break
        }
    }

    // No second shebang, not our business.
    if not starts_with(shebang, "#!"):
        return null
    let bang_args = split(slice(shebang, 2), " ")
    let name = array_shift(bang_args)

    // Find and inject script options into --command
    for i, arg in bang_args {
        if arg == "-i" {
            bang_args[i] = "--command"
            bang_args[i+1] = "{bang_args[i+1]} {file} {args}"
            break
        }
    }
    trust $exec -a {name} {nix_path} "{extras}" "{bang_args}"$
}

/// Launch Nix as a regular CLI.
///
/// **This function does not return.**
pub fun launch_nix(self: Text, args: [Text]): Null
{
    let cache_root = get_cache_root()
    let nix_root = get_nix_root()
    let osname = get_osname()

    let nix_path = "{cache_root}/nix-static"

    let extras = [Text]
    let name = array_last(split(self, "/"))

    if is_nix_installed() {
        migrate_nix_store()
        nix_path = "nix"
    } else {
        get_nix() failed {
            bail("Failed to obtain Nix. Check your internet connection.")
        }
    }

    if file_exists(args[0]) and not ends_with(args[0], ".nix") {
        let args_shebang = args
        array_shift(args_shebang)
        launch_nix_shebang(nix_path, args[0], extras, args_shebang)
    }

    if osname == "Darwin" and not is_nix_installed():
        launch_darwin_workaround(name, nix_path, extras + args)
    else:
        trust $exec -a {name} {nix_path} "{extras}" "{args}"$
}
