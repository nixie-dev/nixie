// Nixie Â© Karim Vergnes <me@thesola.io>
// Licensed under GNU GPLv2
// Common utility functions

import { echo_error, env_var_get } from "std/env"
import { starts_with, text_contains } from "std/text"

let SELF = ""

let me = trust $echo \$0$

// Quick shenanigan to get real path without readlink -f *sideyes macOS*
if text_contains(me, "/") {
    if not starts_with(me, "/") {
        let PWD = trust env_var_get("PWD")
        let rl = $readlink {me}$ failed {
            SELF = "{PWD}/{me}"
        }

        // This second pass check if the result of readlink is relative
        if {
            rl == "":                  SELF = SELF
            not starts_with(rl, "/"):  SELF = "{PWD}/{rl}"
            else:                      SELF = rl
        }
    }
} else {
    echo_error("This script must be run from an absolute or relative path.")
}

// Exit alt-buffer, quit script, kill ourselves. At this point something has gone
// catastrophically wrong and the script MUST stop.
pub fun bail(message: Text): Null
{
    trust $tput rmcup$

    echo_error(message, 1)
    echo_error("This script can be rebuilt using the nixie tool.",1)
    trust $kill -ABRT \$\$$
}

pub fun get_self(): Text
{
    return SELF
}

fun dump_archive(): Text
{
    let dest = trust $mktemp -t nixie_XXXXXXXX.tar$

    // This block seeks to the archive marker, then zcats everything afterwards
    // to the tmpfile in dest
    $cat {SELF} | (
        read -r M
        while ! [[ "\$M" =~ ^-----BEGIN\ ARCHIVE\ SECTION----- ]]
        do read -r M || return 1
        done
        gzip -d -c 2>/dev/null > {dest}
    )$ failed {
        // gzip exits with 2 IFF it sees trailing garbage, which our alt-buf
        // attempt at hiding the tarball technically is
        if status != 2 {
            bail("Could not find the script's resource archive.")
        }
    }

    return dest
}

pub fun untar(member: Text, dump: Bool = false): Text?
{
    let archive = dump_archive()
    let tar_cmd = "tar -x {member} -f {archive}"

    if dump {
        tar_cmd = "tar -x -O {member} -f {archive}"
    }

    let tar_out = ${tar_cmd}$ failed {
        trust $rm {archive}$
        fail status
    }

    trust $rm {archive}$

    return tar_out
}

pub fun check_deps(deps: []): Bool
{
    let missing = [ Text ]

    for dep in deps {
        silent $which {dep}$ failed {
            missing += [ dep ]
        }
    }

    if len(missing) > 0 {
        echo_error("The following commands are missing:", 0)
        for cmd in missing {
            echo_error("- {cmd}", 0)
        }
        echo_error("Use your distribution's package manager to install them, then try again.", 0)
        return false
    }

    return true
}
